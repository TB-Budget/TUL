class "Методы для работы с коллекциями";
inclass private
 tmpSt: Storage;
inclass  public
  proc AddInArray(var Array:Variant[]; Item:Variant);
  var l:Integer;
      l=LengthOfArray(Array);
      Array[l+1]=Item;
  end; 

  func Сравнить synonym Compare, cmp (X: Variant; Y: Variant): Integer;
    var i, ii, k: Integer;
    var Xa, Ya: Variant[];
    if varType(X) < varObject  and varType(Y) < varObject  then
      if varType(X) = varType(Y) then
        -- Тривиальное сравнение скаляров
        if X = Y then
          return 0;
        elsif X > Y then
          return 1;
        else
          return -1;
        end;
      else
        -- В качестве хоть какого-то сравнения разнородных скаляров - сравниваем типы
        if varType(X) > varType(Y) then
          return 1;
        else
          return -1;
        fi;
      end;
    elsif varType(X) = varObject or varType(Y) = varObject  then
      -- Сравнение объектов или объекта с чем попало
      if X = Y then
        -- Перегрузка равенства обеспечена Турбо9
        return 0;
      end;
      -- TODO: проверять на возможность сравнения разнородных
      if X.ClassInfo.MemberByName("LessThan") <> nil:
        if X.LessThan(Y) then
          return -1;
        else
          return 1;
        end;
      elsif Y.ClassInfo.MemberByName("LessThan") <> nil:
        if Y.LessThan(X) then
          return 1;
        else
          return -1;
        end;
      elsif X.ClassInfo.MemberByName("GreaterThan") <> nil:
        if X.GreaterThan(Y) then
          return 1;
        else
          return -1;
        end;
      elsif Y.ClassInfo.MemberByName("GreaterThan") <> nil:
        if Y.GreaterThan(X) then
          return -1;
        else
          return 1;
        end;
      else
        SetError(0, "Несравнимые типы");
      fi;
    elsif varType(X) = varArray and varType(Y) = varArray  then
      Xa = X as Variant[];
      Ya = Y as Variant[];
      -- сравнение массивов
      ii = Min([LengthOfArray(Xa), LengthOfArray(Ya)]);
      for i = 1 .. ii do
        k = cmp(Xa[i], Ya[i]);
        if k <> 0 then
           return k;
        end;
      end;
      -- Все элементы на общей длине равны, больше тот кто длиннее
      Return cmp(LengthOfArray(Xa), LengthOfArray(Ya));
    else
      SetError(0, "Несравнимые типы");
    end;
    Result = 0;
  end;

  func СложениеПоКругу synonym CircleAdd (X: Integer; Y:Integer; maxVal:Integer=0x3FFFFFFF): Integer;
    -- Сложение двух аргументов, так, чтобы результат не превышал maxVal
    -- Если результат потенциально больше - начинаем считать с 0.
    if X < 0 then
      X = Int(Abs(maxVal + X));
    end;
    if Y < 0 then
      Y = Int(Abs(maxVal + Y));
    end;
    while X > maxVal do
      X = X - maxVal;
    end;
    while Y > maxVal do
      Y = Y - maxVal;
    end;
    Result = X + Y;
    while Result > maxVal do
      Result = Result - maxVal;
    end;

  end;

  func Crc2Int(CRC: String): Integer;
    if tmpSt=nil then
       tmpSt = Storage.Create; -- на самом деле сойдет любой объект
    end;
    Result = (tmpSt.Evaluate("0x" + CRC) as Integer);
    Result = Int(Abs(Result));
  end;

  func Хэш synonym Hash (X: Variant): Integer;
    var vt: Integer;
    var tmpS: String;
    var tmpA: Variant[];
    var i, tmpI: Integer;

    vt = VarType(X);
    if vt = varInt then
      return CircleAdd(X, 0);
    elsif vt = varString then
      tmpS = "";
      AddCRC32(tmpS, X);
      return Crc2Int(tmpS);
    elsif vt = varNumeric then
      tmpS = "";
      AddCRC32(tmpS, X);
      return Crc2Int(tmpS);
    elsif vt = varLogical:
      return if(X, 1, 2);
    elsif vt = varDate:
      return Int(PeriodSec(X, 1.1.1900));
    elsif vt = varArray:
      tmpA = X as Variant[];
      Result = 0;
      for i = 1 .. LengthOfArray(tmpA) do
        tmpI = Hash(tmpA[i]);
        if tmpI = -1 then
          return -1;
        else
          Result = CircleAdd(Result, tmpI);
        end;
      end;
    elsif vt = varObject:
      if X.InheritsFrom(Record):
        return Hash(X.ExtID);
      elsif X.InheritsFrom(Sign):
        return Hash(X.DocID);
      elsif X.ClassInfo.MemberByName('Hash') <> nil:
        return Hash(X.Hash);
      else
        return -1; -- не хэшируемые объекты возвращают -1
      fi;
--    elsif vt = varUnit:
--      Result = CircleAdd(Hash(UnitValue(X)),
--                         Hash(UnitFactor(X)));
    else
      Result = -1; -- не хэшируемые объекты возвращают -1
    end;
  end;

  proc Сортировка synonym Sort(var MyArray: Variant[]; KeyFunc: FuncObj=nil); --Сортировка вставками
    var active: Variant;
    var i, j, size :Integer;

    func GetKey(Item: Variant): Variant;
      --Функция взятия ключа приминением фукнции
      if KeyFunc=nil then
         Result = Item;
      else
         Result = KeyFunc.Call([Item]);
      end;
    end;

    size = LengthOfArray(MyArray);
    for i = 2 .. size do
      active = MyArray[i];
      j = i - 1;
      while (j >= 1) and (Compare(GetKey(MyArray[j]),
                                  GetKey(active)) = 1) do
        -- "Проматываем" назад до места, куда надо вставить
        -- т.е. когда "наш" больше предыдущего
        MyArray[j + 1] = MyArray[j];
        j = j - 1;
      od;
      MyArray[j + 1] = active;
    od;
  end;


end