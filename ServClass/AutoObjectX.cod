#Dynamic On;
#Help `Базовая обертка над AutoObject
       Позволяет работать с методами и свойствами AutoObject
       как со своими собственными`;
class "Базовая обертка над AutoObject";
inclass public

var x64 :Logical := ProcessInfo.x64;
var ExistMSScriptControl :Logical := Tul.AutoObjectX._ExistMSScriptControl; -- для разового вычисления в любом из наследников
var _ExistMSScriptControl :Logical := Tul.AutoObjectX.CheckMSScriptControl;
func CheckMSScriptControl :Logical;
  try
    Result = AutoObject.Create("MSScriptControl.ScriptControl") <> nil;
  except
  end;
end;
#Help `Параметр для AutoObject.Create(_OleClass)
       Обязательно перекрывается в наследнике`;
var _OleClass :String;

#Help `Базовый метод приведения типа Variant к своему
       Обязательно перекрывается в наследнике`;
func TSelf(aObject :Variant = nil) :AutoObjectX;
  Result = aObject as AutoObjectX;
end;


#Help `Вызывается в потомке и последовательно в предках (через inherited CreateAsSelf)
       пока не будет создан наиболее подходящий по параметру aObject к классу потомка`;
func CreateAsSelf(aObject :Variant = nil) :AutoObjectX; -- в текущем варианте - просто создаем новый
  Result = AutoObjectX.CreateEx(aObject); -- жестко создаем экземпляр кдасса AutoObjectX
end;


#Help `Базовый "креатор"
       Обязательно перекрывается в наследнике
       параметр aObject может быть AutoObject,
       или строкой OleClassName`;
func CreateEx synonym New (aObject :Variant = nil) :AutoObjectX;
  if aObject is AutoObjectX:
    Result = aObject as AutoObjectX;
  else
    Result = inherited Create;
    if aObject is AutoObject:
      Result._value = aObject;
    elsif aObject <> nil and aObject is String:
      Result._value = AutoObject.Create(aObject as String);
    elsif aObject = nil and _OleClass <> nil:
      Result._value = AutoObject.Create(_OleClass);
    fi;
  fi;
end;

func Create :AutoObjectX;
  Result = CreateEx;
end;

func CreateBase :AutoObjectX;
  Result = inherited Create;
end;


#Help `Получаем Storage с именами полей совпадающими с именами полей _AutoObject
       Реализуется в потомках
       `;
--.InterfaceName :String
--.PropertiesNames :Storage {Field1 = PropertyType1:string ...}
--.MethodsNames :Storage {Meth1 = {"Args"  : [Type1,Type2...], RetValMeth1:TypeRet} ...}
func _AutoObjectRTTI(AO :AutoObject; Param :Storage = nil) :Storage;
  Result = Storage.Create;
end;

#Help `Копируем данные из FromAO: AutoObject в ToStorage :Storage
       Копируем по тем же именам свойств, что в AOStruct :Storage
       Результат - ToStorage
       `;
func AutoObjectToStorge(FromAO: AutoObject; AOStruct :Storage = nil; ToStorage :Storage = nil) :Storage;
  if AOStruct = nil and ToStorage = nil:
    return;
  fi;
  if AOStruct = nil : -- режим обновления полей существующих в ToStorge
    AOStruct = Storage.Create;
    AOStruct.Assign(ToStorage);
    Result = ToStorage;
  elsif ToStorage = nil:
    Result = Storage.Create;
  else
    Result = ToStorage;
  fi;
  var vFieldName :String;
  for var j = 1..AOStruct.count do
    vFieldName = AOStruct.IndexByNumber[j];
    var vFieldValue :Variant = FromAO.Invoke(vFieldName);
    if not Result.FieldExists(vFieldName) and vFieldValue = nil:
      -- не пишем если нет поля в результате и писать нечего
      -- !!!! Нужен отдельный вариант AutoObjectToStorge с полным копированием
    else
      Result[vFieldName] = vFieldValue;
    fi;
  od;
end;



--{ Реализация поддержки динамических полей и свойств
    inclass private
    func GetSelfRttiNames :Storage;
      Result = Storage.Create;
      Result.PropertiesNames = Storage.Create;
    end;

    SelfRttiNames :Storage := GetSelfRttiNames;

    #Help `Хранилище процедур для реализации AutoObject.Fld = Val
             Fld1: proc(AO :AutoObject; Fld :String; Val: Variant)
             Fld2: proc(AO :AutoObject; Fld :String; Val: Variant)
              ...
          `;
    var _SetComField :Storage := Storage.Create;

    inclass public
    #Help `Тип "внешнего" обработчика события GetField`;
    type TGetFieldHandler = func(X :AutoObjectX; aName :String) :Variant;
    #Help `Тип "внешнего" обработчика события SetField`;
    type TSetFieldHandler = func(X :AutoObjectX; aName :String; aValue :Variant) :logical; -- не продолжаем SetField при result = false

    inobject public
    func GetField(aName :String) :Variant;
      if _isSelfProp(aName): -- это свои поля
        Return inherited GetField(aName);
      else
        Return OnGetField(aName);
      fi;
    end;

    proc SetField(aName :String; aValue :Variant);
      if _isSelfProp(aName): -- это свои поля
        inherited SetField(aName, aValue);
      else
        OnSetField(aName, aValue);
      fi;
    end;
    inobject private

   #Help ` "Внешний" обработчик OnGetField`;
    var _OnGetFieldHandlers  :TGetFieldHandler;
   #Help ` "Внешний" обработчик OnSetField`;
    var _OnSetFieldHandlers  :TSetFieldHandler; -- не продолжаем при result = false


    func OnGetField(aName :String) :Variant;
      if _OnGetFieldHandlers <> nil and ClosureOwner(_OnGetFieldHandlers) <> nil:
        Return _OnGetFieldHandlers(Self, aName);
      fi;
      Result = Self[aName];
    end;
    proc OnSetField(aName :String; aValue :Variant);
      if _OnSetFieldHandlers <> nil and ClosureOwner(_OnSetFieldHandlers) <> nil:
        if not _OnSetFieldHandlers(Self, aName, aValue): -- не продолжаем при result = false
          Return;
        fi;
      fi;
      Self[aName] = aValue;
    end;

--}


inobject public

#Help `Вызывается в OnDestroy (перекрывается в наследниках)
       Нужен для "правильной" зачистки всех AutoObject`;
  proc _Clear;
--    if not x64 and _MSScriptControl <> nil:
--      _MSScriptControl.Reset;
--    fi;
  end;

  proc OnDestroy;
   if _AutoObject <> nil:
     _Clear;
     _AutoObject = nil;
   fi;
  end;


  #Help ` Реализуется в наследниках
          Создает представление текущего объекта (если это возможно)
          в виде Storage, в котором любые значения полей будут
            или Storage
            или List
            или чем-то еще...`;
  func _AsStorage :Storage;
    if _AutoObject <> nil:
      Result = Storage.Create;
    fi;
  end;

  #Help ` Реализуется в наследниках
          Создает представление текущего объекта (если это возможно)
          в виде List где каждый элемент-автообъект в виде _AsList или _AsStorage`;
  func _AsList :List;
    if _AutoObject <> nil:
      Result = List.Create;
    fi;
  end;


  #Help ` Реализуется в наследниках
          Проверка на возможность использования свойства _List`;
  func _IsList :Logical;
  end;

  #Help ` Реализуется в наследниках
          Создает представление текущего объекта (если это возможно)
          в виде List`;
  func _AsListValue :List;
    if _IsList:
      Result = List.Create;
      for var j = _ListBegin .. (_ListCount - 1 + _ListBegin) do
        Result.Add(_List[j]);
      od;
    fi;
  end;

  #Help ` Реализуется в наследниках
          Создает представление текущего объекта (если это возможно)
          в виде Storage`;
  func _AsStorageValue :Storage;
    if not _IsList:
      if  _RTTI <> nil and _RTTI.PropertiesNames is Storage:
        var PropertiesNames :Storage = _RTTI.PropertiesNames as Storage;
        Result = Storage.Create;
        for var j = 1..PropertiesNames.Count do
          var vFieldName :String = PropertiesNames.IndexByNumber[j];
          if VarType(PropertiesNames[vFieldName]) = VarArray: -- если массив, то это расшифровка метода, его параметров и типа результата
            -- ничего не делаем для методов
          else -- это свойство
            var vFieldValue :Variant = Self[vFieldName];
            if not Result.FieldExists(vFieldName) and vFieldValue = nil:
              -- не пишем если нет поля в результате и писать нечего
            else
              Result[vFieldName] = vFieldValue;
            fi;
          fi;
        od;
      fi;
    fi;
  end;


  #Default;
  #Help ` позволяет обращатся к self как к Storage
          При использовании второго индекса Param:Variant[]
          позволяет вызывать методы из _AutoObject
          Пример:
          Self['Item',[index]] - аналог _AutoObject.Item(index)`;
  _Items[FieldName :String; Param :Variant[] = nil]: Variant get @_GetItem set @_SetItem;

  #Help ` позволяет обращатся к _AutoObject как к List по целочисленным индексам`;
  _List[index :Integer]: Variant get @_GetListItem set @_SetListItem;

  var _Value :AutoObject get @_GetValue Set @_SetValue;

inobject private

  _AutoObject :AutoObject;

  #Help ` Реализуется в наследниках`;
  func _GetValue :AutoObject;
    Result = _AutoObject;
  end;

  proc _SetValue(aValue :AutoObject);
    _AutoObject = aValue;
--    _MSScriptControl.Run('SetCom', _AutoObject);
  end;

  var _RTTI :Storage := _AutoObjectRTTI(_AutoObject);



  #Help ` Первичный индекс. Перекрывается в наследниках`;
  var _ListBegin :Integer := 1;

  #Help ` Реализуется в наследниках`;
  func _ListCount :Integer;
    Result = Self.Count; -- это пример использования, - аналог _AutoObject.Count
  end;

  #Help ` Реализуется в наследниках`;
  func _GetListItem(index :Integer) :Variant;
    Result = _Items['Item',[index]]; -- это пример использования, - аналог _AutoObject.Item(index)
  end;

  #Help ` Реализуется в наследниках`;
  #if version < 10.4 then
  proc _SetListItem(index :Integer; aValue :Variant);
  #else
  proc _SetListItem(aValue :Variant; index :Integer);
  #end
  end;

  func _GetItem(FieldName :String; Param :Variant[] = nil) :Variant;
    var Res :Variant;
    var vCount :integer = LengthOfArray(Param);
    if vCount = 0: --это свойство
      Res = _AutoObject.Invoke(FieldName);
    elsif vCount = 1: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1]);
    elsif vCount = 2: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2]);
    elsif vCount = 3: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2], Param[3]);
    elsif vCount = 4: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2], Param[3], Param[4]);
    elsif vCount = 5: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2], Param[3], Param[4], Param[5]);
    elsif vCount = 6: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2], Param[3], Param[4], Param[5], Param[6]);
    elsif vCount = 7: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2], Param[3], Param[4], Param[5], Param[6], Param[7]);
    elsif vCount = 8: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2], Param[3], Param[4], Param[5], Param[6], Param[7], Param[8]);
    elsif vCount = 9: --это метод с параметрами
      Res = _AutoObject.Invoke(FieldName, Param[1], Param[2], Param[3], Param[4], Param[5], Param[6], Param[7], Param[8], Param[9]);
    else
      #Warning 'Казунин: !!! Пока не предусмотрено больше 9 параметров >>> надо доделать на 99?';
    fi;
    if Res is AutoObject:
      Result = CreateAsSelf(Res); -- по умолчанию оборачиваем в текущего наследника AutoObjectX
    else
      Result = Res;
    fi;
  end;

#if version < 10.4 then
  proc _SetItem(FieldName :String; Param :Variant[] = nil; aValue :Variant);
#else
  proc _SetItem(aValue :Variant; FieldName :String; Param :Variant[] = nil);
#end
    -- aValue - новое значение
    -- FieldName - имя метода или свойства
    var Fn :Variant = Tul.AutoObjectX._SetComField[FieldName];
    if not Fn is proc(AO :AutoObject; Fld :String; Val: Variant):
      Fn = Evaluate('Proc(AO :AutoObject; Fld :String; Val: Variant) AO.'+FieldName+'= Val; end');
      Tul.AutoObjectX._SetComField[FieldName] = Fn;
    fi;
    var FnSetComField :proc(AO :AutoObject; Fld :String; Val: Variant) = Fn as proc(AO :AutoObject; Fld :String; Val: Variant);
    FnSetComField(_AutoObject, FieldName, aValue);

--    if ExistMSScriptControl:
--      _MSScriptControl_SetComField(FieldName, aValue);
--    fi;
  end;
---------------- блок поддержки для _SetItems --------------

  #Help `Наследуется
         Метод для определения принадлежности свойства к _AutoObject
         Result = false - означает что свойство с именем aPropName относится к _AutoObject`;
  func _isSelfProp(aPropName :String) :Logical;
    Result = aPropName[1] = '_'; -- это свои поля, пока не доделана реализация через SelfRttiNames
    if not Result:
      Result = (SelfRttiNames.PropertiesNames as Storage).FieldExists(aPropName); #Warning 'Казунин: Пока не работает! Доделать! Обязательно искать в своем классе через RTTI!';
    fi;
  end;


--  #Help `Объект содержит метод для записи значения
--         в свойство _AutoObject по имени этого свойства
--         (короче - это костыль т.к. ДИЦ не реализовал эту возможность)`;
--  var _MSScriptControl :AutoObject := _MSScriptControl_ini;
--
--  func _MSScriptControl_ini :AutoObject;
--    if not ExistMSScriptControl:
--      return;
--    fi;
--    Result = AutoObject.Create("MSScriptControl.ScriptControl");
--    try
--      Result.Language="vbscript";
--      Result.AddCode
--       (`Option Explicit
--         Public vCom
--         Public vField
--         Public vValue
--         Public vSelf
--         Sub SetComField(aField, aValue)
--           vField = aField
--           if IsObject(aValue) then
--             set vValue = aValue
--             vSelf.ExecuteStatement("set vCom."&vField&"=vValue")
--             set vValue = nothing
--           else
--             vValue = aValue
--             vSelf.ExecuteStatement("vCom."&vField&"=vValue")
--           end if
--         End Sub
--         Sub SetSelf(aSelf)
--           set vSelf = aSelf
--         End Sub
--         Sub SetCom(aCom)
--           set vCom = nothing
--           set vCom = aCom
--         End Sub`
--        );
--      Result.Run('SetSelf', Result); -- ссылку MSScriptControl во внутрь MSScriptControl в поле vSelf
--      if _AutoObject <> nil:
--        Result.Run('SetCom', _AutoObject);
--      fi;
--    except
--    end;
--  end;
--
--  #Help `Костыльный метод записи в свойство _AutoObject нового значения, используя имя свойства`;
--  Proc _MSScriptControl_SetComField(aProp :String; aValue :Variant);
--    if ExistMSScriptControl:
--      _MSScriptControl.Run('SetComField', aProp, aValue);
--    fi;
--  end;


end
#Dynamic Off;